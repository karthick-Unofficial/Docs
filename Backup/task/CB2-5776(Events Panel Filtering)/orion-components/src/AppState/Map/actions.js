import * as t from "./actionTypes";
import { point, lineString, polygon, multiPolygon } from "@turf/helpers";
import bbox from "@turf/bbox";
import { getDir } from "orion-components/i18n/Config/selector";

/*
 * Set whether the app's map can be interacted with
 */
export const toggleMapVisible = () => {
	return {
		type: t.TOGGLE_MAP_VISIBLE
	};
};

/*
 * Set whether the distance tool is being used
 * @params active: boolean
 */
export const toggleDistanceTool = () => {
	return {
		type: t.TOGGLE_DISTANCE_TOOL
	};
};

/*
 * Set the map object generated by Mapbox
 * @params map: object
 */
export const setMapReference = (map) => {
	return {
		type: t.SET_MAP_REFERENCE,
		payload: { map }
	};
};

export const clearMapReference = () => {
	return {
		type: t.CLEAR_MAP_REFERENCE
	};
};

/*
 * Update visible entities on map
 * Used to check whether an entity can be interacted with on the map and supply geometry to TargetingIcon component
 * @params update: object {feedId: {[entityId]: data}}
 */
export const setMapEntities = (update) => {
	return {
		type: t.SET_MAP_ENTITIES,
		payload: { update }
	};
};

/*
 * Update offset for any movement animations (i.e a profile being open)
 * @params offset: number
 */
export const setMapOffset = (offset) => {
	return {
		type: t.SET_MAP_OFFSET,
		payload: { offset }
	};
};

/*
 * Move to an entity on the map
 * @params e: click event
 * @params geometry: entity's geometry object
 * @params map: map object
 * @params movement: string (ease, fly, jump)
 */
export const moveToTarget = (e, geometry, map, movement = "fly") => {
	return (dispatch, getState) => {
		e.stopPropagation(); // Prevent click through
		const offset = getState().appState.mapRef.offset;
		const ease = movement === "ease";

		let feature;
		switch (geometry.type) {
			case "Point":
				feature = point(geometry.coordinates);
				break;
			case "LineString":
				feature = lineString(geometry.coordinates);
				break;
			case "Polygon":
				feature = polygon(geometry.coordinates);
				break;
			case "MultiPolygon":
				feature = multiPolygon(geometry.coordinates);
				break;
			default:
				break;
		}

		const bounds = bbox(feature);

		let offsetX = offset / 2;
		if (getDir(getState()) === "rtl") {
			offsetX = offsetX * -1;
		}

		map.fitBounds(bounds, {
			offset: [offsetX, 0],
			linear: ease,
			padding: 100,
			maxZoom: 15
		});
	};
};

/**
 * Update the currently in-edit geo
 * @param {object || null} geo
 */
export const setInEditGeo = (geo) => {
	return {
		type: t.SET_IN_EDIT_GEO,
		payload: { geo }
	};
};
