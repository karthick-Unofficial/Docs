"use strict";

var _typeof = require("@babel/runtime-corejs3/helpers/typeof");
var _WeakMap = require("@babel/runtime-corejs3/core-js-stable/weak-map");
var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.toggleMapVisible = exports.toggleDistanceTool = exports.setMapReference = exports.setMapOffset = exports.setMapEntities = exports.setInEditGeo = exports.moveToTarget = exports.clearMapReference = void 0;
var t = _interopRequireWildcard(require("./actionTypes"));
var _helpers = require("@turf/helpers");
var _bbox = _interopRequireDefault(require("@turf/bbox"));
var _selector = require("orion-components/i18n/Config/selector");
function _getRequireWildcardCache(nodeInterop) { if (typeof _WeakMap !== "function") return null; var cacheBabelInterop = new _WeakMap(); var cacheNodeInterop = new _WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? _Object$getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { _Object$defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/*
 * Set whether the app's map can be interacted with
 */
var toggleMapVisible = function toggleMapVisible() {
  return {
    type: t.TOGGLE_MAP_VISIBLE
  };
};

/*
 * Set whether the distance tool is being used
 * @params active: boolean
 */
exports.toggleMapVisible = toggleMapVisible;
var toggleDistanceTool = function toggleDistanceTool() {
  return {
    type: t.TOGGLE_DISTANCE_TOOL
  };
};

/*
 * Set the map object generated by Mapbox
 * @params map: object
 */
exports.toggleDistanceTool = toggleDistanceTool;
var setMapReference = function setMapReference(map) {
  return {
    type: t.SET_MAP_REFERENCE,
    payload: {
      map: map
    }
  };
};
exports.setMapReference = setMapReference;
var clearMapReference = function clearMapReference() {
  return {
    type: t.CLEAR_MAP_REFERENCE
  };
};

/*
 * Update visible entities on map
 * Used to check whether an entity can be interacted with on the map and supply geometry to TargetingIcon component
 * @params update: object {feedId: {[entityId]: data}}
 */
exports.clearMapReference = clearMapReference;
var setMapEntities = function setMapEntities(update) {
  return {
    type: t.SET_MAP_ENTITIES,
    payload: {
      update: update
    }
  };
};

/*
 * Update offset for any movement animations (i.e a profile being open)
 * @params offset: number
 */
exports.setMapEntities = setMapEntities;
var setMapOffset = function setMapOffset(offset) {
  return {
    type: t.SET_MAP_OFFSET,
    payload: {
      offset: offset
    }
  };
};

/*
 * Move to an entity on the map
 * @params e: click event
 * @params geometry: entity's geometry object
 * @params map: map object
 * @params movement: string (ease, fly, jump)
 */
exports.setMapOffset = setMapOffset;
var moveToTarget = function moveToTarget(e, geometry, map) {
  var movement = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "fly";
  return function (dispatch, getState) {
    e.stopPropagation(); // Prevent click through
    var offset = getState().appState.mapRef.offset;
    var ease = movement === "ease";
    var feature;
    switch (geometry.type) {
      case "Point":
        feature = (0, _helpers.point)(geometry.coordinates);
        break;
      case "LineString":
        feature = (0, _helpers.lineString)(geometry.coordinates);
        break;
      case "Polygon":
        feature = (0, _helpers.polygon)(geometry.coordinates);
        break;
      case "MultiPolygon":
        feature = (0, _helpers.multiPolygon)(geometry.coordinates);
        break;
      default:
        break;
    }
    var bounds = (0, _bbox["default"])(feature);
    var offsetX = offset / 2;
    if ((0, _selector.getDir)(getState()) === "rtl") {
      offsetX = offsetX * -1;
    }
    map.fitBounds(bounds, {
      offset: [offsetX, 0],
      linear: ease,
      padding: 100,
      maxZoom: 15
    });
  };
};

/**
 * Update the currently in-edit geo
 * @param {object || null} geo
 */
exports.moveToTarget = moveToTarget;
var setInEditGeo = function setInEditGeo(geo) {
  return {
    type: t.SET_IN_EDIT_GEO,
    payload: {
      geo: geo
    }
  };
};
exports.setInEditGeo = setInEditGeo;